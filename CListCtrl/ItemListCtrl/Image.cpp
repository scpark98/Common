// Picture.cpp : implementation file
//

#include "stdafx.h"
#include "Image.h"

#ifdef _DEBUG
//#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CImage
//---------------------------------------------------------------------------
// 함수설명 : Default Constructor
//---------------------------------------------------------------------------
CImage::CImage()
{
	m_pImage = NULL;

	m_interpolationMode = InterpolationModeBicubic;
}

//---------------------------------------------------------------------------
// 함수설명 : 파일명을 매개 변수로 받는 생성자.
//---------------------------------------------------------------------------
// 변수설명 : strFile : 이미지 경로명 + 파일명 
//---------------------------------------------------------------------------
CImage::CImage(CString strFile)
{
	m_pImage = NULL;

	m_interpolationMode = InterpolationModeDefault;

	Load( strFile );
}

//---------------------------------------------------------------------------
// 함수설명 : CImage 객체를 복사하는 생성자.
//---------------------------------------------------------------------------
CImage::CImage(CImage& imgSource)
{
	m_pImage = NULL;

	m_interpolationMode = InterpolationModeDefault;

	//-----------------------------------------------------------------------
	// 비트맵 객체를 복제한다.
	//-----------------------------------------------------------------------
	m_pImage = imgSource.m_pImage->Clone(0, 0, imgSource.GetWidth() , imgSource.GetHeight() , PixelFormatDontCare );

	//-----------------------------------------------------------------------
	// 비트맵 객체의 명을 저장한다.
	//-----------------------------------------------------------------------
	m_strImage = imgSource.GetFileName();
}

//---------------------------------------------------------------------------
// 함수설명 : Bitmap 객체를 매개 변수로 받는 생성자.
//---------------------------------------------------------------------------
// 부가설명 : Bitmap 객체를 새롭게 생성하여 복사하지 않는다.
//            CImage 클래스가 Bitmap 을 관리하게 됨.
//---------------------------------------------------------------------------
CImage::CImage(Bitmap * pBitmapSource)
{
	m_pImage = pBitmapSource;

	m_interpolationMode = InterpolationModeDefault;
}

//---------------------------------------------------------------------------
// 함수설명 : Image 객체를 매개 변수로 받는 생성자.
//---------------------------------------------------------------------------
// 부가설명 : 1. Image 객체를 Bitmap 객체로 변환해 관리해야함.
//			  2. 매개변수인 Image 객체의 메모리를 해제해야함.
//---------------------------------------------------------------------------
CImage::CImage(Image * pSource)
{
	m_interpolationMode = InterpolationModeDefault;

	//-----------------------------------------------------------------------
	// 새로운 Bitmap 객체를 생성한다.
	//-----------------------------------------------------------------------
	m_pImage = new Bitmap( pSource->GetWidth() , 
						   pSource->GetHeight(),
						   pSource->GetPixelFormat() );

	//-----------------------------------------------------------------------
	// Bitmap 객체의 Graphics 를 얻어와 Image 에 있는 영상을 복사한다.
	//-----------------------------------------------------------------------
	Graphics * pGraphics = Graphics::FromImage( m_pImage );

	pGraphics->DrawImage( pSource, 0, 0, 
						  pSource->GetWidth(), 
						  pSource->GetHeight() );

	//-----------------------------------------------------------------------
	// 사용한 GDI+ 객체를 모두 해제한다.
	//-----------------------------------------------------------------------
	delete pGraphics;
	delete pSource;
}

//---------------------------------------------------------------------------
// 함수설명 : 리소스 아이디를 매개 변수로 받는 생성자.
//---------------------------------------------------------------------------
CImage::CImage(UINT nResource)
{
	m_pImage = NULL;

	m_interpolationMode = InterpolationModeDefault;

	//-----------------------------------------------------------------------
	// 리소스에 있는 이미지를 읽어들인다.
	//-----------------------------------------------------------------------
	Load( nResource );
}

//---------------------------------------------------------------------------
// 함수설명 : 리소스를 이용하여 이미지객체를 생성한다.
//---------------------------------------------------------------------------
// 변수설명 : strResourceType : 리소스타입 예) "GIF"
//			  strResource	  : 리소스명
//---------------------------------------------------------------------------
CImage::CImage(CString strResourceType, CString strResource)
{
	m_pImage = NULL;

	m_interpolationMode = InterpolationModeDefault;

	//-----------------------------------------------------------------------
	// 리소스에 있는 이미지를 읽어들인다.
	//-----------------------------------------------------------------------
	Load( strResourceType, strResource );
}

//---------------------------------------------------------------------------
// 함수설명 : 픽셀 포맷에 맞는 빈 영상을 생성한다.
//---------------------------------------------------------------------------
// 변수설명 : nWidth , nHeight : 영상의 크기 
//			  format : 픽셀의 포맷형식.. GDI+ 를 참조할 것..
//---------------------------------------------------------------------------
CImage::CImage(int nWidth, int nHeight, PixelFormat format)
{
	m_pImage = new Bitmap( nWidth, nHeight, format );

	m_interpolationMode = InterpolationModeDefault;
}

//---------------------------------------------------------------------------
// 함수설명 : 32 비트 ARGB 이미지 객체를 생성한다.
//---------------------------------------------------------------------------
// 변수설명 : pBuffer : UINT 타입의 32비트 칼라 이미지
//			  nWidth , nHeight : 영상의 크기 
//---------------------------------------------------------------------------
CImage::CImage(UINT* pBuffer, int nWidth, int nHeight)
{
	m_pImage = NULL;

	Create( pBuffer, nWidth, nHeight , true );
}

CImage::~CImage()
{
	UnLoad();
}

//----------------------------------------------------------------------------
// 함수설명 : 현재 이미지 객체를 복사한다.
//----------------------------------------------------------------------------
// 부가설명 : 이 함수를 사용하는 곳에서는 반환된 객체를 관리(삭제)해야 함.
//----------------------------------------------------------------------------
CImage * CImage::Clone()
{
	return (CImage*)new CImage(*this);
}

//----------------------------------------------------------------------------
// 함수설명 : 32 비트 ARGB 칼라 영상을 생성한다.
//----------------------------------------------------------------------------
// 변수설명 : pBuffer : 32비트 ARGB 칼라 영상 정보
//			  nWidth  : 영상의 폭 
//		  	  nHeight : 영상의 높이
//			  bDelete : pBuffer 의 내용을 삭제할 것인지를 나타냄.
//----------------------------------------------------------------------------
bool CImage::Create(UINT *pBuffer, int nWidth, int nHeight, bool bDelete)
{
	//------------------------------------------------------------------------
	// 이전 비트맵 객체가 존재하면 이를 삭제한다.
	//------------------------------------------------------------------------
	UnLoad();

	//------------------------------------------------------------------------
	// 32비트 ARGB 칼라 영상을 생성한다.
	//------------------------------------------------------------------------
	m_pImage = new Bitmap( nWidth, nHeight, PixelFormat32bppARGB );

	if( m_pImage == NULL ) return false;

	//------------------------------------------------------------------------
	// pBuffer 에 있는 내용을 생성된 비트맵 객체에 복사한다.
	//------------------------------------------------------------------------
	bool bResult = SetBuffer( m_pImage , pBuffer );

	if( bDelete == true ) delete[] pBuffer;

	return bResult;
}

//----------------------------------------------------------------------------
// 함수설명 : 지정된 영상을 이용하여 새로운 영상을 지정한다.
//----------------------------------------------------------------------------
CImage& CImage::operator=(CImage& imgSource)
{
	UnLoad();

	//-----------------------------------------------------------------------
	// 비트맵 객체를 복제한다.
	//-----------------------------------------------------------------------
	m_pImage = imgSource.m_pImage->Clone(0, 0, imgSource.GetWidth() , imgSource.GetHeight(), PixelFormatDontCare);

	//-----------------------------------------------------------------------
	// 비트맵 객체의 명을 저장한다.
	//-----------------------------------------------------------------------
	m_strImage = imgSource.GetFileName();

	return *this;
}

//----------------------------------------------------------------------------
// 함수설명 : 이미지명을 지정한다.
//----------------------------------------------------------------------------
void CImage::SetFileName(CString strImage)
{
	//-------------------------------------------------------------------------
	// 이미지 객체의 경로와 파일명을 저장한다.
	//-------------------------------------------------------------------------
	m_strImage = strImage;
}

//----------------------------------------------------------------------------
// 함수설명 : 지정된 이미지의 경로와 파일명을 반환한다.
//----------------------------------------------------------------------------
CString CImage::GetFileName()
{
	return  m_strImage;
}

//----------------------------------------------------------------------------
// 함수설명 : 지정된 이미지를 지정된 Device Context에 출력한다.
//----------------------------------------------------------------------------
// 변수설명 : pDC	 : Device Context 의 포인터
//			  x		 : 이미지가 출력될 x 위치
//			  y      : 이미지가 출력될 y 위치
//			  nWidth : 출력될 이미지의 가로측 크기
//			  nHeight: 출력될 이미지의 세로측 크기
//			  clrMask: Mask 처리될 색상 즉 투명하게 처리될 색상
//			  fAlpha : 전체 영상의 Alpha 값 ( Blending 정도 )
//----------------------------------------------------------------------------
void CImage::Draw(CDC *pDC, int x, int y, int nWidth, int nHeight , COLORREF clrMask , float fAlpha )
{
	//------------------------------------------------------------------------
	// Graphics Object를 생성한다.
	//------------------------------------------------------------------------
	Graphics graphics(pDC->GetSafeHdc());
	Draw( &graphics , x, y, nWidth, nHeight, clrMask, fAlpha );	
}

//----------------------------------------------------------------------------
// 함수설명 : 지정된 이미지를 지정된 Device Context에 출력한다.
//----------------------------------------------------------------------------
// 변수설명 : pDC	 : Device Context 의 포인터
//			  rcImage: 영상이 출력될 영역
//			  clrMask: Mask 처리될 색상 즉 투명하게 처리될 색상
//			  fAlpha : 전체 영상의 Alpha 값 ( Blending 정도 )
//----------------------------------------------------------------------------
void CImage::Draw(CDC *pDC, Rect rcImage, COLORREF clrMask , float fAlpha )
{
	Draw( pDC , rcImage.X, rcImage.Y, rcImage.Width, rcImage.Height, clrMask, fAlpha );	
}

//----------------------------------------------------------------------------
// 함수설명 : 지정된 이미지를 지정된 Device Context에 출력한다.
//----------------------------------------------------------------------------
// 변수설명 : pDC	 : Device Context 의 포인터
//			  x		 : 이미지가 출력될 x 위치
//			  y      : 이미지가 출력될 y 위치
//			  clrMask: Mask 처리될 색상 즉 투명하게 처리될 색상
//			  fAlpha : 전체 영상의 Alpha 값 ( Blending 정도 )
//----------------------------------------------------------------------------
void CImage::Draw(CDC *pDC, int x, int y, COLORREF clrMask, float fAlpha)
{
	//------------------------------------------------------------------------
	// Graphics Object를 생성한다.
	//------------------------------------------------------------------------
	Graphics graphics(pDC->GetSafeHdc());
	Draw( &graphics , x, y, clrMask, fAlpha );	
}


//----------------------------------------------------------------------------
// 함수설명 : 지정된 이미지를 지정된 Device Context에 출력한다.
//----------------------------------------------------------------------------
// 변수설명 : pDC	 : Device Context 의 포인터
//			  x		 : 이미지가 출력될 x 위치
//			  y      : 이미지가 출력될 y 위치
//			  nWidth : 출력될 이미지의 가로측 크기
//			  nHeight: 출력될 이미지의 세로측 크기
//----------------------------------------------------------------------------
void CImage::Draw(CDC *pDC, int x, int y, int nWidth, int nHeight)
{
	//------------------------------------------------------------------------
	// Graphics Object를 생성한다.
	//------------------------------------------------------------------------
	Graphics graphics(pDC->GetSafeHdc());
	Draw( &graphics , x, y, nWidth, nHeight );
}

//----------------------------------------------------------------------------
// 함수설명 : 지정된 이미지를 지정된 Device Context에 출력한다.
//----------------------------------------------------------------------------
// 변수설명 : pDC	 : Device Context 의 포인터
//			  rcImage: 영상이 출력될 영역
//----------------------------------------------------------------------------
void CImage::Draw(CDC *pDC, Rect rcImage)
{
	Draw( pDC , rcImage.X, rcImage.Y, rcImage.Width, rcImage.Height );
}

//----------------------------------------------------------------------------
// 함수설명 : 이미지의 특정 부분을 지정된 Device Context에 출력한다.
//----------------------------------------------------------------------------
// 변수설명 : rcDest : Destination 영역 좌표
//			  rcSrc  : Source 영역 좌표
//			  fAlpha : Alpha Channel 값 
//----------------------------------------------------------------------------
void CImage::Draw(CDC * pDC, Rect rcDest, Rect rcSrc , float fAlpha )
{
	Graphics graphics(pDC->GetSafeHdc());
	Draw( &graphics , rcDest, rcSrc , fAlpha );
}

//----------------------------------------------------------------------------
// 함수설명 : 이미지의 특정 부분을 지정된 Device Context에 출력한다.
//----------------------------------------------------------------------------
// 변수설명 : rcDest : Destination 영역 좌표
//			  rcSrc  : Source 영역 좌표
//			  clrMask: Mask 처리될 색상 즉 투명하게 처리될 색상
//			  fAlpha : Alpha Channel 값 
//----------------------------------------------------------------------------
void CImage::Draw(CDC * pDC, Rect rcDest, Rect rcSrc , COLORREF clrMask , float fAlpha )
{
	Graphics graphics(pDC->GetSafeHdc());
	Draw( &graphics , rcDest, rcSrc , clrMask, fAlpha );
}

//----------------------------------------------------------------------------
// 함수설명 : 지정된 이미지를 지정된 Device Context에 출력한다.
//----------------------------------------------------------------------------
// 변수설명 : pDC	 : Device Context 의 포인터
//			  x		 : 이미지가 출력될 x 위치
//			  y      : 이미지가 출력될 y 위치
//----------------------------------------------------------------------------
void CImage::Draw(CDC *pDC, int x, int y)
{
	Graphics graphics(pDC->GetSafeHdc());
	Draw( &graphics , x, y );
}

//----------------------------------------------------------------------------
// 함수설명 : 이미지의 특정 부분을 지정된 Device Context에 출력한다.
//----------------------------------------------------------------------------
// 변수설명 : rcDest : Destination 영역 좌표
//			  rcSrc  : Source 영역 좌표
//			  fAlpha : Alpha Channel 값 
//----------------------------------------------------------------------------
void CImage::Draw(Graphics* pGraphics, Rect rcDest, Rect rcSrc , float fAlpha )
{
	if( m_pImage != NULL )
	{
		//-------------------------------------------------------
		// 1. 전체 영상의 Alpha 값을 지정한다.
		//-------------------------------------------------------
		ColorMatrix	clrMatix =	{ 1 , 0 , 0 , 0 , 0 , 
								  0 , 1 , 0 , 0 , 0 , 
								  0 , 0 , 1 , 0 , 0 , 
								  0 , 0 , 0 , fAlpha , 0 , 
								  0 , 0 , 0 , 0 , 1 };

		//-------------------------------------------------------
		// ColorMatrix를 사용해서 Image Attribute 객체를 생성한다.
		//-------------------------------------------------------
		ImageAttributes imgAttr;
		imgAttr.SetColorMatrix(&clrMatix , ColorMatrixFlagsDefault , ColorAdjustTypeBitmap );

		//-------------------------------------------------------
		// 보간법(Interpolation) 을 현 함수에만 한정하기 위해서 
		// GraphicsContainer 를 이용한다.
		//-------------------------------------------------------
		GraphicsContainer graphicsContainer = pGraphics->BeginContainer();
		
		pGraphics->SetInterpolationMode( m_interpolationMode );

		pGraphics->DrawImage( m_pImage , rcDest, rcSrc.X, rcSrc.Y, 
							  rcSrc.Width, rcSrc.Height, UnitPixel , &imgAttr );

		pGraphics->EndContainer(graphicsContainer);
	}
}

//----------------------------------------------------------------------------
// 함수설명 : 이미지의 특정 부분을 지정된 Device Context에 출력한다.
//----------------------------------------------------------------------------
// 변수설명 : rcDest : Destination 영역 좌표
//			  rcSrc  : Source 영역 좌표
//			  clrMask: Mask 처리될 색상 즉 투명하게 처리될 색상
//			  fAlpha : Alpha Channel 값 
//----------------------------------------------------------------------------
void CImage::Draw(Graphics* pGraphics, Rect rcDest, Rect rcSrc , COLORREF clrMask , float fAlpha )
{
	if( m_pImage != NULL )
	{
		//-------------------------------------------------------
		// 1. Mask 처리될 색상을 위한 칼라맵을 생성한다.
		//-------------------------------------------------------
		ColorMap clrMap;
		clrMap.oldColor = Color( 255, GetRValue(clrMask), GetGValue(clrMask), GetBValue(clrMask)); 
		clrMap.newColor = Color( 0 , GetRValue(clrMask), GetGValue(clrMask), GetBValue(clrMask));

		ImageAttributes imgAttr;
		imgAttr.SetRemapTable(1, &clrMap,ColorAdjustTypeDefault);

		//-------------------------------------------------------
		// Mask 처리된 이미지를 저장하기 위한 임시 객체 
		//-------------------------------------------------------
		Bitmap bmTemp(rcSrc.Width, rcSrc.Height, PixelFormat32bppARGB );

		Graphics graphicsTemp(&bmTemp);
		graphicsTemp.DrawImage( m_pImage, Rect(0,0,rcSrc.Width, rcSrc.Height), rcSrc.X , rcSrc.Y, 
							rcSrc.Width, rcSrc.Height , UnitPixel , &imgAttr );

		//-------------------------------------------------------
		// 출력할 영상의 속성을 지정한다.
		//-------------------------------------------------------
		// 2. 전체 영상의 Alpha 값을 지정한다.
		//-------------------------------------------------------
		ColorMatrix	clrMatix =	{ 1 , 0 , 0 , 0 , 0 , 
								  0 , 1 , 0 , 0 , 0 , 
								  0 , 0 , 1 , 0 , 0 , 
								  0 , 0 , 0 , fAlpha , 0 , 
								  0 , 0 , 0 , 0 , 1 };

		//-------------------------------------------------------
		// ColorMatrix를 사용해서 Image Attribute 객체를 생성한다.
		//-------------------------------------------------------
		imgAttr.SetColorMatrix(&clrMatix , ColorMatrixFlagsDefault , ColorAdjustTypeBitmap );

		//-------------------------------------------------------
		// 보간법(Interpolation) 을 현 함수에만 한정하기 위해서 
		// GraphicsContainer 를 이용한다.
		//-------------------------------------------------------
		GraphicsContainer graphicsContainer = pGraphics->BeginContainer();
		
		pGraphics->SetInterpolationMode( m_interpolationMode );

		pGraphics->DrawImage( &bmTemp , rcDest, 0, 0 , rcSrc.Width , rcSrc.Height, 
							  UnitPixel , &imgAttr );

		pGraphics->EndContainer(graphicsContainer);
	}
}

//----------------------------------------------------------------------------
// 함수설명 : 지정된 이미지를 지정된 Device Context에 출력한다.
//----------------------------------------------------------------------------
// 변수설명 : pG	 : GDI+의 Graphics 의 포인터
//			  x		 : 이미지가 출력될 x 위치
//			  y      : 이미지가 출력될 y 위치
//			  nWidth : 출력될 이미지의 가로측 크기
//			  nHeight: 출력될 이미지의 세로측 크기
//			  clrMask: Mask 처리될 색상 즉 투명하게 처리될 색상
//			  fAlpha : 전체 영상의 Alpha 값 ( Blending 정도 )
//----------------------------------------------------------------------------
void CImage::Draw(Graphics* pGraphics, int x, int y, int nWidth, int nHeight , COLORREF clrMask , float fAlpha )
{
	if( m_pImage == NULL ) return;

	Draw( pGraphics, Rect(x, y, nWidth, nHeight), Rect(0, 0, m_pImage->GetWidth(), m_pImage->GetHeight()),
		  clrMask , fAlpha );
}

//----------------------------------------------------------------------------
// 함수설명 : 지정된 이미지를 지정된 Device Context에 출력한다.
//----------------------------------------------------------------------------
// 변수설명 : pG	 : GDI+의 Graphics 의 포인터
//			  rcImage: 영상이 출력될 영역
//			  clrMask: Mask 처리될 색상 즉 투명하게 처리될 색상
//			  fAlpha : 전체 영상의 Alpha 값 ( Blending 정도 )
//----------------------------------------------------------------------------
void CImage::Draw(Graphics* pG, Rect rcImage , COLORREF clrMask , float fAlpha )
{
	Draw( pG , rcImage.X, rcImage.Y , rcImage.Width, rcImage.Height, clrMask, fAlpha );
}

//----------------------------------------------------------------------------
// 함수설명 : 지정된 이미지를 지정된 Device Context에 출력한다.
//----------------------------------------------------------------------------
// 변수설명 : pG	 : GDI+의 Graphics 의 포인터
//			  x		 : 이미지가 출력될 x 위치
//			  y      : 이미지가 출력될 y 위치
//			  clrMask: Mask 처리될 색상 즉 투명하게 처리될 색상
//			  fAlpha : 전체 영상의 Alpha 값 ( Blending 정도 )
//----------------------------------------------------------------------------
void CImage::Draw(Graphics* pG, int x, int y, COLORREF clrMask, float fAlpha)
{
	if( m_pImage != NULL )
	{
		Draw(pG, x, y, m_pImage->GetWidth(), m_pImage->GetHeight(), clrMask , fAlpha );
	}
}

//----------------------------------------------------------------------------
// 함수설명 : 지정된 이미지를 지정된 Device Context에 출력한다.
//----------------------------------------------------------------------------
// 변수설명 : pG	 : GDI+의 Graphics 의 포인터
//			  x		 : 이미지가 출력될 x 위치
//			  y      : 이미지가 출력될 y 위치
//			  nWidth : 출력될 이미지의 가로측 크기
//			  nHeight: 출력될 이미지의 세로측 크기
//			  fAlpha : 전체 영상의 Alpha 값 ( Blending 정도 )
//----------------------------------------------------------------------------
void CImage::Draw(Graphics * pGraphics, int x, int y, int nWidth, int nHeight , float fAlpha )
{
	if( m_pImage == NULL ) return;

	Draw( pGraphics, Rect(x, y, nWidth, nHeight) , Rect(0, 0, m_pImage->GetWidth(), m_pImage->GetHeight()), fAlpha );
}

//----------------------------------------------------------------------------
// 함수설명 : 지정된 이미지를 지정된 Device Context에 출력한다.
//----------------------------------------------------------------------------
// 변수설명 : pG	 : GDI+의 Graphics 의 포인터
//			  rcImage: 영상이 출력될 영역
//			  fAlpha : 전체 영상의 Alpha 값 ( Blending 정도 )
//----------------------------------------------------------------------------
void CImage::Draw(Graphics * pG, Rect rcImage , float fAlpha )
{
	Draw( pG, rcImage.X, rcImage.Y, rcImage.Width, rcImage.Height , fAlpha );
}

//----------------------------------------------------------------------------
// 함수설명 : 지정된 이미지를 지정된 Device Context에 출력한다.
//----------------------------------------------------------------------------
// 변수설명 : pG	 : GDI+의 Graphics 의 포인터
//			  x		 : 이미지가 출력될 x 위치
//			  y      : 이미지가 출력될 y 위치
//			  fAlpha : 전체 영상의 Alpha 값 ( Blending 정도 )
//----------------------------------------------------------------------------
void CImage::Draw(Graphics * pG, int x, int y, float fAlpha)
{
	if( m_pImage != NULL )
	{
		Draw(pG, x, y, m_pImage->GetWidth(), m_pImage->GetHeight(), fAlpha );
	}
}

//----------------------------------------------------------------------------
// 함수설명 : 지정된 이미지를 지정된 Device Context에 출력한다.
//----------------------------------------------------------------------------
// 변수설명 : pG	 : GDI+의 Graphics 의 포인터
//			  rcImage: 영상이 출력될 영역
//----------------------------------------------------------------------------
void CImage::Draw(Graphics * pG, Rect rcImage)
{
	Draw( pG , rcImage.X, rcImage.Y, rcImage.Width, rcImage.Height );
}

//----------------------------------------------------------------------------
// 함수설명 : 지정된 이미지를 지정된 Device Context에 출력한다.
//----------------------------------------------------------------------------
// 변수설명 : pG	 : GDI+의 Graphics 의 포인터
//			  x		 : 이미지가 출력될 x 위치
//			  y      : 이미지가 출력될 y 위치
//			  nWidth : 출력될 이미지의 가로측 크기
//			  nHeight: 출력될 이미지의 세로측 크기
//----------------------------------------------------------------------------
void CImage::Draw(Graphics * pGraphics, int x, int y, int nWidth, int nHeight)
{
	if( m_pImage != NULL )
	{
		GraphicsContainer graphicsContainer = pGraphics->BeginContainer();
		
		pGraphics->SetInterpolationMode( m_interpolationMode );

		pGraphics->DrawImage( m_pImage, x, y, nWidth, nHeight );

		pGraphics->EndContainer(graphicsContainer);
	}
}

//----------------------------------------------------------------------------
// 함수설명 : 지정된 이미지를 지정된 Device Context에 출력한다.
//----------------------------------------------------------------------------
// 변수설명 : pG	 : GDI+의 Graphics 의 포인터
//			  x		 : 이미지가 출력될 x 위치
//			  y      : 이미지가 출력될 y 위치
//----------------------------------------------------------------------------
void CImage::Draw(Graphics * pGraphics, int x, int y)
{
	if( m_pImage != NULL )
	{
		GraphicsContainer graphicsContainer = pGraphics->BeginContainer();
		
		pGraphics->SetInterpolationMode( m_interpolationMode );

		pGraphics->DrawImage( m_pImage, x, y , m_pImage->GetWidth() , m_pImage->GetHeight() );

		pGraphics->EndContainer(graphicsContainer);
	}
}

//----------------------------------------------------------------------------
// 함수설명 : 이미지에서 지정된 위치의 색상정보를 지정한다.
//----------------------------------------------------------------------------
bool CImage::SetPixel(int x, int y, COLORREF clrPixel)
{
	if( m_pImage == NULL ) return false;
		
	Color clrNew(255, 0, 0, 0);
	clrNew.SetFromCOLORREF(clrPixel); 

	Status status = m_pImage->SetPixel(x, y, clrNew);

	if( status != Ok ) return false;

	return true;
}

//----------------------------------------------------------------------------
// 함수설명 : 이미지에서 지정된 위치의 색상정보를 지정한다.
//----------------------------------------------------------------------------
bool CImage::SetPixel(Point ptPos, COLORREF clrPixel)
{
	if( m_pImage == NULL ) return false;

	Color clrNew(255, 0, 0, 0);
	clrNew.SetFromCOLORREF(clrPixel); 

	Status status = m_pImage->SetPixel(ptPos.X, ptPos.Y, clrNew);

	if( status != Ok ) return false;

	return true;
}

//----------------------------------------------------------------------------
// 함수설명 : 이미지에서 지정된 위치의 색상정보를 얻어온다.
//----------------------------------------------------------------------------
COLORREF CImage::GetPixel(int x, int y)
{
	COLORREF clrPixel = RGB(0,0,0);

	if( m_pImage != NULL )
	{
		Color clrTemp;
		m_pImage->GetPixel(x, y, &clrTemp);

		clrPixel = RGB(clrTemp.GetR(), clrTemp.GetG(), clrTemp.GetB() );
	}

	return clrPixel;
}

//----------------------------------------------------------------------------
// 함수설명 : 이미지에서 지정된 위치의 색상정보를 얻어온다.
//----------------------------------------------------------------------------
COLORREF CImage::GetPixel(Point ptPos)
{
	COLORREF clrPixel = RGB(0,0,0);

	if( m_pImage != NULL )
	{
		Color clrTemp;
		m_pImage->GetPixel(ptPos.X , ptPos.Y , &clrTemp);

		clrPixel = RGB(clrTemp.GetR(), clrTemp.GetG(), clrTemp.GetB() );
	}

	return clrPixel;
}

//----------------------------------------------------------------------------
// 함수설명 : 이미지에서 지정된 위치의 색상정보를 지정한다.
//----------------------------------------------------------------------------
bool CImage::SetPixel(int x, int y, Color& clrPixel)
{
	if( m_pImage == NULL ) return false;

	Status status = m_pImage->SetPixel(x, y, clrPixel);

	if( status != Ok ) return false;

	return true;
}

//----------------------------------------------------------------------------
// 함수설명 : 이미지에서 지정된 위치의 색상정보를 지정한다.
//----------------------------------------------------------------------------
bool CImage::SetPixel(Point ptPos, Color& clrPixel)
{
	if( m_pImage == NULL ) return false;
			
	Status status = m_pImage->SetPixel(ptPos.X, ptPos.Y, clrPixel);

	if( status != Ok ) return false;

	return true;
}

//----------------------------------------------------------------------------
// 함수설명 : 이미지에서 지정된 위치의 색상정보를 얻어온다.
//----------------------------------------------------------------------------
void CImage::GetPixel(int x, int y, Color& clrPixel)
{
	if( m_pImage != NULL )
	{
		m_pImage->GetPixel(x, y, &clrPixel);
	}
}

//----------------------------------------------------------------------------
// 함수설명 : 이미지에서 지정된 위치의 색상정보를 얻어온다.
//----------------------------------------------------------------------------
void CImage::GetPixel(Point ptPos, Color& clrPixel)
{
	GetPixel(ptPos.X , ptPos.Y, clrPixel);
}

//----------------------------------------------------------------------------
// 함수설명 : 이미지에서 영상정보를 저장하고 있는 버퍼를 얻어온다.
//----------------------------------------------------------------------------
// 주의사항 : 이 함수를 사용하는 곳에서는 반환된 버퍼를 해제해 주어야 한다.
//			  예) delete[] pBuffer;	
//----------------------------------------------------------------------------
BYTE * CImage::GetBuffer()
{
	if( m_pImage == NULL ) return NULL;

	return GetBuffer( m_pImage , m_pImage->GetPixelFormat() );
}

//----------------------------------------------------------------------------
// 함수설명 : 이미지에서 영상정보를 저장하고 있는 버퍼를 얻어온다.
//----------------------------------------------------------------------------
// 변수설명 : pixelFormat : 얻고자 하는 영상정보 타입을 나타냄.
//----------------------------------------------------------------------------
// 주의사항 : 이 함수를 사용하는 곳에서는 반환된 버퍼를 해제해 주어야 한다.
//			  예) delete[] pBuffer;	
//----------------------------------------------------------------------------
BYTE * CImage::GetBuffer(PixelFormat pixelFormat)
{
	return GetBuffer( m_pImage , pixelFormat );
}

//----------------------------------------------------------------------------
// 함수설명 : 이미지에서 지정된 영역의 영상정보를 얻어온다.
//----------------------------------------------------------------------------
// 변수설명 : rcImage      : 영상내에서 얻고자 하는 부분
//----------------------------------------------------------------------------
// 주의사항 : 이 함수를 사용하는 곳에서는 반환된 버퍼를 해제해 주어야 한다.
//			  예) delete[] pBuffer;	
//----------------------------------------------------------------------------
BYTE * CImage::GetBuffer(Rect rcImage)
{
	if( m_pImage == NULL ) return NULL;

	return GetBuffer( m_pImage, rcImage, m_pImage->GetPixelFormat() );
}

//----------------------------------------------------------------------------
// 함수설명 : 이미지에서 지정된 영역의 영상정보를 얻어온다.
//----------------------------------------------------------------------------
// 변수설명 : rcImage      : 영상내에서 얻고자 하는 부분
//			  pixelFormat : 얻고자 하는 영상정보 타입을 나타냄.
//----------------------------------------------------------------------------
// 주의사항 : 이 함수를 사용하는 곳에서는 반환된 버퍼를 해제해 주어야 한다.
//			  예) delete[] pBuffer;	
//----------------------------------------------------------------------------
BYTE * CImage::GetBuffer(Rect rcImage, PixelFormat pixelFormat)
{
	return GetBuffer( m_pImage, rcImage, pixelFormat );
}

//----------------------------------------------------------------------------
// 함수설명 : 이미지에서 영상정보를 저장하고 있는 버퍼를 얻어온다.
//----------------------------------------------------------------------------
// 변수설명 : pImage	  : 영상정보를 포함하고 있는 Bitmap 객체의 포인터
//			  pixelFormat : 얻고자 하는 영상정보 타입을 나타냄.
//----------------------------------------------------------------------------
// 주의사항 : 이 함수를 사용하는 곳에서는 반환된 버퍼를 해제해 주어야 한다.
//			  예) delete[] pBuffer;	
//----------------------------------------------------------------------------
BYTE * CImage::GetBuffer( Bitmap * pImage , PixelFormat pixelFormat)
{
	if( pImage == NULL ) return NULL;
	
	//------------------------------------------------------------------------
	// 영상의 전체 데이타를 가지고 있는 BitmapData 를 얻어온다.
	//------------------------------------------------------------------------
	BitmapData bmData;

	//------------------------------------------------------------------------
	// 영상의 크기를 얻어온다.
	//------------------------------------------------------------------------
	int nWidth = pImage->GetWidth();
	int nHeight = pImage->GetHeight();

	//------------------------------------------------------------------------
	// 메모리에 고정시킬 영상의 영역을 지정한다.  (전체영상데이타)
	//------------------------------------------------------------------------
	Rect rcImage(0, 0, nWidth, nHeight );

	//------------------------------------------------------------------------
	// 영상 비트맵 정보를 얻어온다.
	//------------------------------------------------------------------------
	Status status = pImage->LockBits( &rcImage , ImageLockModeRead , pixelFormat , &bmData );

	if( status != Ok ) return NULL;

	//------------------------------------------------------------------------
	// 영상의 전체 데이타를 얻기위한 위한 메모리를 할당한다.
	//------------------------------------------------------------------------
	// Stride : 영상의 한줄당 차지하고 있는 전체 바이트의 수를 나타냄.
	//          ( 영상의 메모리 폭 Stride 는 4의 배수로 맞쳐진다. )
	//------------------------------------------------------------------------
	//          양수 : Top-down 방식의 이미지를 나타냄.
	//			음수 : Buttom-up 방식의 이미지를 나타냄.
	//------------------------------------------------------------------------

	//------------------------------------------------------------------------
	// 실 영상 데이타를 위한 Stride 를 계산한다. ( 폭 * 픽셀당 바이트수 )
	//------------------------------------------------------------------------
	UINT nStride = nWidth * GetBytesForPixel( pixelFormat ) * sizeof(BYTE);
	UINT nSize = nStride * nHeight;

	BYTE * pBuffer = new BYTE[nSize];

	//------------------------------------------------------------------------
	// 영상의 전체 데이타를 메모리에 카피한다. (Stride 를 고려함.)
	//------------------------------------------------------------------------
	for( int nRow = 0 ; nRow < nHeight ; nRow++ )
	{
		CopyMemory( pBuffer + nStride*nRow , 
					(BYTE *)bmData.Scan0 + abs(bmData.Stride)*nRow , 
					nStride );
	}
		
	pImage->UnlockBits(&bmData);

	return pBuffer;
}

//----------------------------------------------------------------------------
// 함수설명 : 지정된 영역의 영상정보를 얻어온다.
//----------------------------------------------------------------------------
// 변수설명 : pImage	  : 영상정보를 포함하고 있는 Bitmap 객체의 포인터
//			  rcImage	  : 얻고자 하는 영상영역정보
//			  pixelFormat : 얻고자 하는 영상정보 타입을 나타냄.
//----------------------------------------------------------------------------
// 주의사항 : 이 함수를 사용하는 곳에서는 반환된 버퍼를 해제해 주어야 한다.
//			  예) delete[] pBuffer;	
//----------------------------------------------------------------------------
BYTE * CImage::GetBuffer(Bitmap * pImage, Rect rcImage, PixelFormat pixelFormat )
{
	if( pImage == NULL ) return NULL;

	//------------------------------------------------------------------------
	// 영상의 전체 데이타를 가지고 있는 BitmapData 를 얻어온다.
	//------------------------------------------------------------------------
	BitmapData bmData;

	//------------------------------------------------------------------------
	// 영역의 크기를 얻어온다.
	//------------------------------------------------------------------------
	int nWidth = rcImage.Width;
	int nHeight = rcImage.Height;

	//------------------------------------------------------------------------
	// 영상 비트맵 정보를 얻어온다. (전체 영역을 얻어온다.)
	//------------------------------------------------------------------------
	// 일부분만 가져오면 비율에 문제가 생김..( 찾아야 하는뎅..ㅡㅡ;; )
	//------------------------------------------------------------------------
	Rect rcAll(0 , 0 , pImage->GetWidth(), pImage->GetHeight() );
	Status status = pImage->LockBits( &rcAll , ImageLockModeRead , pixelFormat , &bmData );

//	Status status = pImage->LockBits( &rcImage , ImageLockModeRead , pixelFormat , &bmData );

	if( status != Ok ) return NULL;

	//------------------------------------------------------------------------
	// 영상의 전체 데이타를 얻기위한 위한 메모리를 할당한다.
	//------------------------------------------------------------------------
	// Stride : 영상의 한줄당 차지하고 있는 전체 바이트의 수를 나타냄.
	//          ( 영상의 메모리 폭 Stride 는 4의 배수로 맞쳐진다. )
	//------------------------------------------------------------------------
	//          양수 : Top-down 방식의 이미지를 나타냄.
	//			음수 : Buttom-up 방식의 이미지를 나타냄.
	//------------------------------------------------------------------------

	//------------------------------------------------------------------------
	// 실 영상 데이타를 위한 Stride 를 계산한다. ( 폭 * 픽셀당 바이트수 )
	//------------------------------------------------------------------------
	UINT nBytes = GetBytesForPixel( pixelFormat );
	UINT nStride = nWidth * nBytes * sizeof(BYTE);
	UINT nSize = nStride * nHeight;

	BYTE * pBuffer = new BYTE[nSize];

	//------------------------------------------------------------------------
	// 지정된 위치의 영상 데이타를 메모리에 카피한다. (Stride 를 고려함.)
	//------------------------------------------------------------------------
	// 고정시키지 않은 메모리 영역에 접근하면 에러를 발생시킴.
	//------------------------------------------------------------------------
	for( int nRow = 0 ; nRow < nHeight ; nRow++ )
	{
		CopyMemory( pBuffer + nStride*nRow , 
					(BYTE *)bmData.Scan0 + abs(bmData.Stride)*(rcImage.Y + nRow) + rcImage.X*nBytes, 
					nStride );
	}

	pImage->UnlockBits(&bmData);

	return pBuffer;
}

//----------------------------------------------------------------------------
// 함수설명 : 사용자 데이타를 이용해서 영상정보를 변경한다.
//----------------------------------------------------------------------------
// 변수설명 : pImage	  : Bitmap 객체에 대한 포인터 
//			  pBuffer	  : 영상정보를 가지고 있는 메모리 버퍼 	
//----------------------------------------------------------------------------
bool CImage::SetBuffer(Bitmap * pImage, UINT * pBuffer)
{
	return SetBuffer( pImage , (BYTE *)pBuffer , PixelFormat32bppARGB );
}

//----------------------------------------------------------------------------
// 함수설명 : 사용자 데이타를 이용해서 영상정보를 변경한다.
//----------------------------------------------------------------------------
// 변수설명 : pImage	  : Bitmap 객체에 대한 포인터 
//			  rcImage	  : 변경하려는 영상의 영역정보
//			  pBuffer	  : 영상정보를 가지고 있는 메모리 버퍼 	
//----------------------------------------------------------------------------
bool CImage::SetBuffer(Bitmap * pImage, UINT * pBuffer, Rect rcImage)
{
	return SetBuffer( pImage, (BYTE *)pBuffer, rcImage, PixelFormat32bppARGB );
}

//----------------------------------------------------------------------------
// 함수설명 : 사용자 데이타를 이용해서 전체 영상정보를 변경한다.
//----------------------------------------------------------------------------
// 변수설명 : pImage	  : Bitmap 객체에 대한 포인터 
//			  pBuffer	  : 영상정보를 가지고 있는 메모리 버퍼 	
//			  pixelFormat : 영상의 픽셀포맷을 나타냄.
//----------------------------------------------------------------------------
// 부가설명 : pBuffer의 영상정보는 4의 배수로 맞쳐지는 Stride 를 고려하지 
//			  않았기 때문에 이 정보를 폭을 4의 배수로 맞쳐줄 필요가 있다.
//
//			  여기선 부분복사를 이용하여 Stride 문제를 해결함.
//----------------------------------------------------------------------------
bool CImage::SetBuffer(Bitmap * pImage, BYTE * pBuffer, PixelFormat pixelFormat)
{
	if( pImage == NULL ) return false;
	
	//------------------------------------------------------------------------
	// 영상의 크기를 얻어온다.
	//------------------------------------------------------------------------
	int nWidth = pImage->GetWidth();
	int nHeight = pImage->GetHeight();

	//------------------------------------------------------------------------
	// 변경할 영상 영역을 지정한다. (전체영역)
	//------------------------------------------------------------------------
	Rect rcImage(0, 0, nWidth, nHeight );
	
	return SetBuffer( pImage, pBuffer, rcImage, pixelFormat );
}

//----------------------------------------------------------------------------
// 함수설명 : 사용자 데이타를 이용해서 일부 영상정보를 변경한다.
//----------------------------------------------------------------------------
// 변수설명 : pImage	  : Bitmap 객체에 대한 포인터 
//			  pBuffer	  : 영상정보를 가지고 있는 메모리 버퍼 	
//			  rcImage	  : 변경하려는 영상의 영역정보
//			  pixelFormat : 영상의 픽셀포맷을 나타냄.
//----------------------------------------------------------------------------
bool CImage::SetBuffer(Bitmap * pImage, BYTE * pBuffer, Rect rcImage, PixelFormat pixelFormat)
{
	if( pImage == NULL ) return false;
	
	//------------------------------------------------------------------------
	// 영상의 전체 데이타를 가지고 있는 BitmapData 를 얻어온다.
	//------------------------------------------------------------------------
	BitmapData bmData;

	//------------------------------------------------------------------------
	// 변경할 영상 영역을 메모리에 고정시킨다.
	//------------------------------------------------------------------------
	//------------------------------------------------------------------------
	// 영상 비트맵 정보를 얻어온다. (전체 영역을 얻어온다.)
	//------------------------------------------------------------------------
	// 일부분만 가져오면 비율에 문제가 생김..( 찾아야 하는뎅..ㅡㅡ;; )
	//------------------------------------------------------------------------
	Rect rcAll(0 , 0 , pImage->GetWidth(), pImage->GetHeight() );
	Status status = pImage->LockBits( &rcAll , ImageLockModeWrite , pixelFormat , &bmData );

//	Status status = pImage->LockBits( &rcImage , ImageLockModeWrite , pixelFormat , &bmData );

	if( status != Ok ) return false;

	//------------------------------------------------------------------------
	// 영상 데이타를 위한 Stride 를 계산한다. ( 폭 * 픽셀당 바이트수 )
	//------------------------------------------------------------------------
	UINT nBytes = GetBytesForPixel( pixelFormat );
	UINT nStride = rcImage.Width * nBytes * sizeof(BYTE);

	//------------------------------------------------------------------------
	// 메모리에 고정된 영상 영역의 내용을 변경한다.
	//------------------------------------------------------------------------
	for( int nRow = 0 ; nRow < rcImage.Height ; nRow++ )
	{
		CopyMemory( (BYTE *)bmData.Scan0 + abs(bmData.Stride)*(rcImage.Y + nRow) + rcImage.X*nBytes, 
					pBuffer + nStride*nRow , nStride );
	}

	pImage->UnlockBits(&bmData);

	return true;
}

//----------------------------------------------------------------------------
// 함수설명 : 사용자 데이타를 이용해서 영상정보를 변경한다.
//----------------------------------------------------------------------------
// 변수설명 : pBuffer	  : ARGB 영상정보를 가지고 있는 메모리 버퍼 	
//----------------------------------------------------------------------------
bool CImage::SetBuffer( UINT * pBuffer )
{
	return SetBuffer( m_pImage , pBuffer );
}

//----------------------------------------------------------------------------
// 함수설명 : 사용자 데이타를 이용해서 영상정보를 변경한다.
//----------------------------------------------------------------------------
// 변수설명 : pBuffer	  : ARGB 영상정보를 가지고 있는 메모리 버퍼 	
//			  rcImage	  : 변경할 영역정보
//----------------------------------------------------------------------------
bool CImage::SetBuffer( UINT * pBuffer, Rect rcImage )
{
	return SetBuffer( m_pImage , pBuffer , rcImage );
}

//----------------------------------------------------------------------------
// 함수설명 : 사용자 데이타를 이용해서 영상정보를 변경한다.
//----------------------------------------------------------------------------
// 변수설명 : pImage	  : Image 정보
//			  rcImage	  : 변경할 영역정보
//----------------------------------------------------------------------------
// 부가설명 : TRUE Color 영상에 대해서만 사용할 수 있다.
//----------------------------------------------------------------------------
bool CImage::SetBuffer( CImage * pImage , Rect rcImage )
{
	bool bResult;

	if( pImage->GetBytesForPixel() == 1 ) return false;

	UINT * pBuffer = (UINT*)pImage->GetBuffer( PixelFormat32bppARGB );

	bResult = SetBuffer( pBuffer , rcImage );

	delete[] pBuffer;

	return bResult;
}

//----------------------------------------------------------------------------
// 함수설명 : 사용자 데이타를 이용해서 영상정보를 변경한다.
//----------------------------------------------------------------------------
// 변수설명 : pBuffer	  : 영상정보를 가지고 있는 메모리 버퍼 	
//			  pixelFormat : 영상의 픽셀포맷을 나타냄.
//----------------------------------------------------------------------------
bool CImage::SetBuffer( BYTE * pBuffer , PixelFormat pixelFormat )
{
	return SetBuffer( m_pImage , pBuffer , pixelFormat );
}

//----------------------------------------------------------------------------
// 함수설명 : 사용자 데이타를 이용해서 영상정보를 변경한다.
//----------------------------------------------------------------------------
// 변수설명 : pBuffer	  : 영상정보를 가지고 있는 메모리 버퍼 	
//			  rcImage	  : 변경할 영역정보
//			  pixelFormat : 영상의 픽셀포맷을 나타냄.
//----------------------------------------------------------------------------
bool CImage::SetBuffer( BYTE * pBuffer, Rect rcImage, PixelFormat pixelFormat)
{
	return SetBuffer( m_pImage , pBuffer , rcImage,  pixelFormat );
}

//----------------------------------------------------------------------------
// 함수설명 : 사용자 데이타를 이용해서 영상정보를 변경한다.
//----------------------------------------------------------------------------
// 변수설명 : pBuffer : 영상정보를 가지고 있는 메모리 버퍼 	
//----------------------------------------------------------------------------
// 부가설명 : pBuffer 의 크기는 원영상의 픽셀포맷에 형태로 되어 있어야 한다.
//----------------------------------------------------------------------------
bool CImage::SetBuffer(BYTE * pBuffer)
{
	if( m_pImage == NULL ) return false;

	return SetBuffer( m_pImage , (BYTE *)pBuffer , m_pImage->GetPixelFormat() );
}

//----------------------------------------------------------------------------
// 함수설명 : 사용자 데이타를 이용해서 영상정보를 변경한다.
//----------------------------------------------------------------------------
// 변수설명 : pBuffer : 영상정보를 가지고 있는 메모리 버퍼 	
//			  rcImage  : 변경할 영역정보
//----------------------------------------------------------------------------
// 부가설명 : pBuffer 의 크기는 원영상의 픽셀포맷에 형태로 되어 있어야 한다.
//----------------------------------------------------------------------------
bool CImage::SetBuffer(BYTE* pBuffer, Rect rcImage)
{
	if( m_pImage == NULL ) return false;

	return SetBuffer( m_pImage, (BYTE *)pBuffer, rcImage, m_pImage->GetPixelFormat() );
}

//----------------------------------------------------------------------------
// 함수설명 : 영상의 크기를 Rect 타입으로 반환한다.
//----------------------------------------------------------------------------
Rect CImage::GetRect()
{
	return Rect( 0 , 0 , GetWidth(), GetHeight() );
}

//----------------------------------------------------------------------------
// 함수설명 : 영상데이타의 폭 길이를 반환한다.
//----------------------------------------------------------------------------
UINT CImage::GetWidth()
{
	if( m_pImage != NULL )
	{
		return m_pImage->GetWidth();
	}

	return 0;
}

//----------------------------------------------------------------------------
// 함수설명 : 영상데이타의 높이의 길이를 반환한다.
//----------------------------------------------------------------------------
UINT CImage::GetHeight()
{
	if( m_pImage != NULL )
	{
		return m_pImage->GetHeight();
	}

	return 0;
}

//----------------------------------------------------------------------------
// 함수설명 : 썸네일 영상을 만들어 반환한다.
//			  16 비트 영상을 만든다.
//----------------------------------------------------------------------------
// 변수설명 : nWidth  : 썸네일 영상의 가로 크기.
//			  nHeight : 썸네일 영상의 세로 크기.
//			  Interpolation : 썸네일 영상을 만들때의 보간법 (Interpolation)
//----------------------------------------------------------------------------
// 부가설명 : 이 함수를 호출하는 곳에서는 반드시 메모리를 삭제해야 한다.
//----------------------------------------------------------------------------
CImage * CImage::GetThumbnailImage(int nWidth, int nHeight, InterpolationMode interpolationMode )
{
	//------------------------------------------------------------------------
	// 새로운 이미지 객체를 생성한다.
	//------------------------------------------------------------------------
	CImage * pImage = new CImage( nWidth, nHeight, PixelFormat16bppRGB555 );

	//------------------------------------------------------------------------
	// 새롭게 생성된 이미지에서 Graphcis 객체를 얻는다.
	//------------------------------------------------------------------------
	Graphics * pGraphics = Graphics::FromImage( pImage->m_pImage );
	
	//------------------------------------------------------------------------
	// 얻어진 Graphics 를 이용하여 원본 이미지를 줄여서 출력한다.
	//------------------------------------------------------------------------
	GraphicsContainer graphicsContainer = pGraphics->BeginContainer();
	
	pGraphics->SetInterpolationMode( interpolationMode );

	Status state = pGraphics->DrawImage( m_pImage, 0, 0,nWidth,nHeight );

	pGraphics->EndContainer(graphicsContainer);	
	//------------------------------------------------------------------------
	// 사용한 그래픽스 객체를 삭제한다.
	//------------------------------------------------------------------------
	delete pGraphics;

	return pImage;
}

//----------------------------------------------------------------------------
// 함수설명 : 썸네일 영상을 만들어 반환한다.
//----------------------------------------------------------------------------
// 변수설명 : fXScale : 썸네일 영상의 가로 비율 
//			  fYScale : 썸네일 영상의 세로 비율
//			  Interpolation : 썸네일 영상을 만들때의 보간법 (Interpolation)
//----------------------------------------------------------------------------
// 부가설명 : 이 함수를 호출하는 곳에서는 반드시 메모리를 삭제해야 한다.
//----------------------------------------------------------------------------
CImage * CImage::GetThumbnailImage(float fXScale, float fYScale, InterpolationMode interpolationMode )
{
	int nWidth = int( m_pImage->GetWidth() * fXScale );
	int nHeight = int( m_pImage->GetHeight() * fYScale );

	return GetThumbnailImage(nWidth, nHeight, interpolationMode );
}

//---------------------------------------------------------------------------
// 함수설명 : 영상의 픽셀정보를 얻어온다.
//---------------------------------------------------------------------------
PixelFormat CImage::GetPixelFormat()
{
	return m_pImage->GetPixelFormat();
}

//---------------------------------------------------------------------------
// 함수설명 : 영상의 픽셀당 바이트 수를 얻어온다.
//---------------------------------------------------------------------------
// 부가설명 : 본 프로그램에서는 아래와 같은 방식으로 픽셀을 처리함.
//
//			   1 BYTE    
//					PixelFormat1bppIndexed         
//					PixelFormat4bppIndexed  
//		 			PixelFormat8bppIndexed
//				    PixelFormat16bppGrayScale
//				3 BYTE ( R+G+B )
//				    PixelFormat16bppRGB555
//				    PixelFormat16bppRGB565
//				    PixelFormat24bppRGB 
//				    PixelFormat32bppRGB
//				4 BYTE	(A+R+G+B)
//				    PixelFormat16bppARGB1555
//				    PixelFormat32bppARGB 
//				    PixelFormat32bppPARGB    
//--------------------------------------------------------------------------
int CImage::GetBytesForPixel(PixelFormat pixelFormat)
{
	int nByte = 0;

	switch( pixelFormat )
	{
	case PixelFormat1bppIndexed:
	case PixelFormat4bppIndexed:
	case PixelFormat8bppIndexed:
		{
			nByte = 1;
		}
		break;

	case PixelFormat16bppGrayScale:
	case PixelFormat16bppRGB555:
	case PixelFormat16bppRGB565:
	case PixelFormat16bppARGB1555:
		{
			nByte = 2;
		}
		break;

	case PixelFormat24bppRGB:
		{
			nByte = 3;
		}
		break;

	case PixelFormat32bppARGB:
	case PixelFormat32bppPARGB:
	case PixelFormat32bppRGB:
		{
			nByte = 4;
		}
		break;

	default:
		{
			nByte = 3;
		}
	}

	return nByte;
}

//---------------------------------------------------------------------------
// 함수설명 : 영상의 픽셀당 바이트 수를 얻어온다.
//---------------------------------------------------------------------------
// 부가설명 : 본 프로그램에서는 아래와 같은 방식으로 픽셀을 처리함.
//
//			   1 BYTE    
//					PixelFormat1bppIndexed         
//					PixelFormat4bppIndexed  
//		 			PixelFormat8bppIndexed
//				    PixelFormat16bppGrayScale
//				3 BYTE ( R+G+B )
//				    PixelFormat16bppRGB555
//				    PixelFormat16bppRGB565
//				    PixelFormat24bppRGB 
//				    PixelFormat32bppRGB
//				4 BYTE	(A+R+G+B)
//				    PixelFormat16bppARGB1555
//				    PixelFormat32bppARGB 
//				    PixelFormat32bppPARGB    
//----------------------------------------------------------------------------
int CImage::GetBytesForPixel()
{
	return GetBytesForPixel( GetPixelFormat() );
}

//---------------------------------------------------------------------------
// 함수설명 : 새로운 이미지를 리소스에서 읽어들인다.
//---------------------------------------------------------------------------
// 변수설명 : nResource : 리소스 아이디를 나타냄.
//---------------------------------------------------------------------------
bool CImage::Load( UINT nResource )
{
	//-----------------------------------------------------------------------
	// 이미지 객체가 기존에 존재한다면 이를 삭제한다.
	//-----------------------------------------------------------------------
	UnLoad();

	//-----------------------------------------------------------------------
	// 리소스에 있는 이미지를 읽어들인다.
	//-----------------------------------------------------------------------
	CBitmap bmResource;

	if( bmResource.LoadBitmap( nResource ) == FALSE )		
	{
		return false;
	}

	m_pImage = new Bitmap( bmResource , NULL );

	return true;
}

//---------------------------------------------------------------------------
// 함수설명 : 새로운 이미지를 리소스에서 읽어들인다.
//---------------------------------------------------------------------------
// 변수설명 : strResourceType : 리소스의 타입을 나타냄 예) "GIF"
//			  strResource     : 리소스명을 나타냄.
//---------------------------------------------------------------------------
bool CImage::Load(CString strResourceType, CString strResource)
{
	//-----------------------------------------------------------------------
	// 이미지 객체가 기존에 존재한다면 이를 삭제한다.
	//-----------------------------------------------------------------------
	UnLoad();

	IStream * pStream = NULL;

	//-----------------------------------------------------------------------
	// Stream 객체를 생성한다.
	//-----------------------------------------------------------------------
	if( !CreateStream( strResourceType, strResource, pStream ) ) return false;

	if( pStream == NULL ) return false;

	//-----------------------------------------------------------------------
	// Bitmap 객체를 생성한다.
	//-----------------------------------------------------------------------
	m_pImage = new Bitmap(pStream);

	//-----------------------------------------------------------------------
	// 사용한 Stream 객체를 해제한다.
	//-----------------------------------------------------------------------
	pStream->Release();

	return true;	
}

//---------------------------------------------------------------------------
// 함수설명 : 새로운 이미지를 메모리로 읽어들인다.
//---------------------------------------------------------------------------
// 변수설명 : strImage : 이미지의 경로와 파일명을 나타낸다.
//---------------------------------------------------------------------------
bool CImage::Load(CString strFile)
{
	//-----------------------------------------------------------------------
	// 이미지 객체가 기존에 존재한다면 이를 삭제한다.
	//-----------------------------------------------------------------------
	UnLoad();

	//-----------------------------------------------------------------------
	// 읽어들일 이미지명을 저장한다.
	//-----------------------------------------------------------------------
	SetFileName( strFile );

	if( strFile.IsEmpty() )
	{
		return true;
	}

	//-----------------------------------------------------------------------
	// MBCS 를 Unicode로 변경한다.
	//-----------------------------------------------------------------------
	int nSizeCount = MultiByteToWideChar( CP_ACP, 0, m_strImage , -1, NULL, 0 );
	WCHAR * pWString = new WCHAR[nSizeCount];
	MultiByteToWideChar( CP_ACP, 0, m_strImage , -1 , pWString , nSizeCount );

	//-----------------------------------------------------------------------
	// 임시 이미지 객체를 생성하여 지정된 이미지를 메모리로 읽어들인다.
	//-----------------------------------------------------------------------
	m_pImage = new Bitmap( pWString );

	delete[] pWString;

	return true;
}

//--------------------------------------------------------------------------
// 함수설명 : 리소스를 이용하여 IStream 을 생성한다.
//--------------------------------------------------------------------------
// 변수설명 : strResourceType : 리소스 타입
//			  strResource	  : 리소스명
//			  IStream		  : 반환될 스트림 객체에 대한 포인터
//--------------------------------------------------------------------------
bool CImage::CreateStream(CString strResourceType, CString strResource, IStream* pIStream)
{
	//-----------------------------------------------------------------------
	// 리소스에 있는 정보를 얻어온다.
	//-----------------------------------------------------------------------
	int			nLen	= 0;
	bool		bResult	= FALSE;

	HINSTANCE hRInstance = AfxGetResourceHandle();
	//-----------------------------------------------------------------------
	// 리소스 위치를 찾는다.
	//-----------------------------------------------------------------------
	HRSRC hResInfo = FindResource(hRInstance, strResource, strResourceType );

	if (hResInfo == NULL) return false;
	//-----------------------------------------------------------------------
	// 리소스를 읽어들인다.
	//-----------------------------------------------------------------------
	HANDLE hRes = LoadResource(hRInstance, hResInfo);

	if (hRes == NULL) return false;

	//-----------------------------------------------------------------------
	// 리소스를 메모리에 LOCK 시킨다.
	//-----------------------------------------------------------------------
	LPSTR lpRes = (char*)LockResource(hRes);

	if(lpRes == NULL)
	{
		FreeResource(hRes);
		return false;
	}

	//-----------------------------------------------------------------------
	// 리소스를 위한 메모리크기를 얻어온후 메모리를 할당한다.
	//-----------------------------------------------------------------------
	int nSize = SizeofResource(hRInstance , hResInfo);

	//-----------------------------------------------------------------------
	// GlobalAlloc 을 사용하여 버퍼를 생성한다.
	//-----------------------------------------------------------------------
	LPBYTE pBuffer = (LPBYTE)GlobalAlloc( GMEM_FIXED , nSize );

	if( pBuffer == NULL )
	{
		UnlockResource(hRes);
		FreeResource(hRes);

		return false;
	}

	//----------------------------------------------------------------------
	// Stream 객체를 생성한다.
	//----------------------------------------------------------------------
	if( CreateStreamOnHGlobal( pBuffer , TRUE , &pIStream ) != S_OK )
	{
		GlobalFree((HGLOBAL)pBuffer);
		UnlockResource(hRes);
		FreeResource(hRes);

		return false;
	}

	//----------------------------------------------------------------------
	// 사용한 리소스를 풀고 해제한다.
	//----------------------------------------------------------------------
	UnlockResource(hRes);
	FreeResource(hRes);

	return true;
}

//--------------------------------------------------------------------------
// 함수설명 : 사용했던 정보를 모두 해제한다.
//--------------------------------------------------------------------------
// 부가설명 : 1. 보간법 (Interpolation) 을 기본값으로 복원한다.
//			  2. 생성된 이미지를 삭제한다.           
//--------------------------------------------------------------------------
void CImage::UnLoad()
{
	m_interpolationMode = InterpolationModeDefault;

	if( m_pImage != NULL )
	{
		delete m_pImage;
		m_pImage = NULL;
	}
}

//--------------------------------------------------------------------------
// 함수설명 : 영상정보를 저장하기 위한 함수 
//--------------------------------------------------------------------------
// 변수설명 : strFile : 이미지의 경로와 파일명을 나타낸다.
//--------------------------------------------------------------------------
bool CImage::Save(CString strFile, long lQuality)
{
	bool bResult = false;

	strFile.MakeLower();

	if( strFile.Find(".jpg") != -1 || strFile.Find(".jpeg") != -1 )
	{
		bResult = SaveToJpeg( strFile , lQuality );
	}
	else if( strFile.Find(".gif") != -1 )
	{
		bResult = SaveToGif( strFile );
	}
	else if( strFile.Find(".bmp") != -1 )
	{
		bResult = SaveToBmp( strFile );
	}

	return bResult;
}

//--------------------------------------------------------------------------
// 함수설명 : 비트맵 객체에 저정되어 있는 정보를 Jpeg 데이타로 저장한다.
//--------------------------------------------------------------------------
// 변수설명 : strFile : 이미지의 경로와 파일명을 나타낸다.
//--------------------------------------------------------------------------
bool CImage::SaveToJpeg(CString strFile, long lQuality)
{
	//----------------------------------------------------------------------
	// MBCS 를 Unicode로 변경한다.
	//----------------------------------------------------------------------
	int nSizeCount = MultiByteToWideChar( CP_ACP, 0, strFile , -1, NULL, 0 );
	WCHAR * pWString = new WCHAR[nSizeCount];
	MultiByteToWideChar( CP_ACP, 0, strFile , -1 , pWString , nSizeCount );

	//----------------------------------------------------------------------
	// 코덱의 클래스아이디를 얻어온다. 속성을 지정한다.
	//----------------------------------------------------------------------
	CLSID		clsidCodec;

	if( -1 == GetCodecClsid(L"image/jpeg", &clsidCodec ) ) return false;

	//----------------------------------------------------------------------
	// JPEG 속성을 지정한다.
	//----------------------------------------------------------------------
	EncoderParameters	encoderParams;

	encoderParams.Count = 1;
	encoderParams.Parameter[0].Guid = EncoderQuality;
	encoderParams.Parameter[0].Type = EncoderParameterValueTypeLong;
	encoderParams.Parameter[0].NumberOfValues = 1;
	encoderParams.Parameter[0].Value = &lQuality;

	Status state = m_pImage->Save( pWString , &clsidCodec , &encoderParams );

	delete[] pWString;

	if(state != Ok)	return false;

	return true;
}

//--------------------------------------------------------------------------
// 함수설명 : 비트맵 객체에 저정되어 있는 정보를 GIF 데이타로 저장한다.
//--------------------------------------------------------------------------
// 부가설명 : 현재 GDI+ 1.0 안에 있는 GIF 코덱은 255 칼라이미지만 제공됨.
//--------------------------------------------------------------------------
// 변수설명 : strFile : 이미지의 경로와 파일명을 나타낸다.
//--------------------------------------------------------------------------
bool CImage::SaveToGif(CString strFile)
{
	//----------------------------------------------------------------------
	// MBCS 를 Unicode로 변경한다.
	//----------------------------------------------------------------------
	int nSizeCount = MultiByteToWideChar( CP_ACP, 0, strFile , -1, NULL, 0 );
	WCHAR * pWString = new WCHAR[nSizeCount];
	MultiByteToWideChar( CP_ACP, 0, strFile , -1 , pWString , nSizeCount );

	//----------------------------------------------------------------------
	// 코덱의 클래스아이디를 얻어온다. 속성을 지정한다.
	//----------------------------------------------------------------------
	CLSID		clsidCodec;

	if( -1 == GetCodecClsid(L"image/gif", &clsidCodec ) ) return false;

	//----------------------------------------------------------------------
	// GIF 속성을 지정한다.
	//----------------------------------------------------------------------
	EncoderParameters	encoderParams;

	long lValue = EncoderValueVersionGif89;

	encoderParams.Count = 1;
	encoderParams.Parameter[0].Guid = EncoderVersion;
	encoderParams.Parameter[0].Type = EncoderParameterValueTypeLong;
	encoderParams.Parameter[0].NumberOfValues = 1;
	encoderParams.Parameter[0].Value = &lValue;

	Status state = m_pImage->Save( pWString , &clsidCodec , &encoderParams );

	delete[] pWString;

	if(state != Ok)	return false;

	return true;
}

//--------------------------------------------------------------------------
// 함수설명 : 비트맵 객체에 저정되어 있는 정보를 Bitmap 데이타로 저장한다.
//--------------------------------------------------------------------------
// 변수설명 : strFile : 이미지의 경로와 파일명을 나타낸다.
//--------------------------------------------------------------------------
bool CImage::SaveToBmp(CString strFile)
{
	//----------------------------------------------------------------------
	// MBCS 를 Unicode로 변경한다.
	//----------------------------------------------------------------------
	int nSizeCount = MultiByteToWideChar( CP_ACP, 0, strFile , -1, NULL, 0 );
	WCHAR * pWString = new WCHAR[nSizeCount];
	MultiByteToWideChar( CP_ACP, 0, strFile , -1 , pWString , nSizeCount );

	//----------------------------------------------------------------------
	// 코덱의 클래스아이디를 얻어온다. 속성을 지정한다.
	//----------------------------------------------------------------------
	CLSID		clsidCodec;

	if( -1 == GetCodecClsid(L"image/bmp", &clsidCodec ) ) return false;

	Status state = m_pImage->Save( pWString , &clsidCodec , NULL );

	delete[] pWString;

	if(state != Ok)	return false;

	return true;
}

//--------------------------------------------------------------------------
// 함수설명 : 시스템에 설치되어 있는 이미지 코덱에 대한 CLSID 를 얻어온다.
//--------------------------------------------------------------------------
// 반환값   : -1이면 해당 코덱을 찾지 못했다는 것을 나타냄.
//--------------------------------------------------------------------------
int CImage::GetCodecClsid(const WCHAR *format, CLSID *pClsid)
{
	UINT  nCodecNum = 0;
	UINT  nCodecInfoSize = 0;

	ImageCodecInfo * pImageCodecInfo = NULL;
	
	//----------------------------------------------------------------------
	// 코덱의 갯수와 코덱정보를 읽기 위한 메모리사이즈를 얻어온다.
	//----------------------------------------------------------------------
 	GetImageEncodersSize(&nCodecNum , &nCodecInfoSize );
	
	if( nCodecInfoSize == 0 )
		return -1;
	
	pImageCodecInfo = (ImageCodecInfo*)new BYTE[nCodecInfoSize];

	if( pImageCodecInfo == NULL )
		return -1;

	//----------------------------------------------------------------------
	// 코덱의 정보를 얻어온다.
	//----------------------------------------------------------------------	
	GetImageEncoders( nCodecNum , nCodecInfoSize , pImageCodecInfo );	

	for( int nIndex = 0 ; nIndex < nCodecNum ; nIndex++ )
	{	
		if( wcscmp(pImageCodecInfo[nIndex].MimeType , format ) == 0 )
		{
			* pClsid = pImageCodecInfo[nIndex].Clsid;
			delete[] pImageCodecInfo;

			return nIndex;
		}
	}

	delete[] pImageCodecInfo;
	
	return -1;
}

//--------------------------------------------------------------------------
// 함수설명 : 현재 이미지의 Palette 사이즈를 반환한다.
//--------------------------------------------------------------------------
int CImage::GetPaletteSize()
{
	if( m_pImage == NULL )	return 0;

	return m_pImage->GetPaletteSize();
}

//----------------------------------------------------------------------------
// 함수설명 : 현재 이미지의 Palette 를 반환한다.
//----------------------------------------------------------------------------
// 부가설명 : 이 함수를 사용하는 곳에서는 반드시 반환된 메모리를 삭제해야 한다.
//----------------------------------------------------------------------------
ColorPalette * CImage::GetPalette()
{
	if( m_pImage == NULL )	return NULL;

	//------------------------------------------------------------------------
	// 팔레트를 위한 메모리를 할당한다.
	//------------------------------------------------------------------------
	ColorPalette * pPal = new ColorPalette[ GetPaletteSize() ];

	//------------------------------------------------------------------------
	// 영상안에 저장되어 있는 팔레트 정보를 얻어온다.
	//------------------------------------------------------------------------
	Status stat = m_pImage->GetPalette( pPal , GetPaletteSize() );

	return pPal;
}

//----------------------------------------------------------------------------
// 함수설명 : 이미지의 Palette 를 지정한다.
//----------------------------------------------------------------------------
void CImage::SetPalette( ColorPalette * pPal )
{
	if( m_pImage == NULL ) return;

	m_pImage->SetPalette( pPal );
}

//----------------------------------------------------------------------------
// 함수설명 : GDI+ Bitmap 객체로부터 Graphics 객체를 얻는다.
//----------------------------------------------------------------------------
// 부가설명 : 반환받은 Graphics 객체는 삭제를 해줘야 한다.
//----------------------------------------------------------------------------
Graphics * CImage::GetGraphics()
{
	if( m_pImage == NULL ) return NULL;

	return Graphics::FromImage( m_pImage );
}

//----------------------------------------------------------------------------
// 함수설명 : 영상을 줄이거나 늘릴때 보간법(Interpolation) 을 지정한다.
//----------------------------------------------------------------------------
// 부가설명 : GDI+ 에서 제공하는 Interpolation 종류 
//
//			  InterpolationModeInvalid = QualityModeInvalid,
//			  InterpolationModeDefault = QualityModeDefault,
//			  InterpolationModeLowQuality = QualityModeLow,
//			  InterpolationModeHighQuality = QualityModeHigh,
//			  InterpolationModeBilinear,
//			  InterpolationModeBicubic,
//			  InterpolationModeNearestNeighbor,
//			  InterpolationModeHighQualityBilinear,
//			  InterpolationModeHighQualityBicubic
//----------------------------------------------------------------------------
InterpolationMode CImage::SetInterpolationMode(InterpolationMode interpolationMode)
{
	InterpolationMode temp = m_interpolationMode;
	m_interpolationMode = interpolationMode;

	return temp;
}

//----------------------------------------------------------------------------
// 함수설명 : 지정된 보간법(Interpolation) 모드 값을 반환한다.
//----------------------------------------------------------------------------
InterpolationMode CImage::GetInterpolationMode()
{
	return m_interpolationMode;
}

//----------------------------------------------------------------------------
// 함수설명 : 이미지의 프레임갯수를 반환한다.
//----------------------------------------------------------------------------
int CImage::GetFrameCount()
{
	if( m_pImage == NULL ) return 0;

    UINT nDCount = m_pImage->GetFrameDimensionsCount();
	GUID* pDimensionIDs = new GUID[nDCount];

	//-----------------------------------------------------------------------
	// 이미지 객체로부터 Dimension 정보를 얻어온다.
	//-----------------------------------------------------------------------
	m_pImage->GetFrameDimensionsList(pDimensionIDs, nDCount);

   	//-----------------------------------------------------------------------
	// 첫번째 Dimension 에서 Frame 의 정보를 얻어온다.
	//-----------------------------------------------------------------------
    int nFrameCount = m_pImage->GetFrameCount(&pDimensionIDs[0]);

    delete[] pDimensionIDs;

	return nFrameCount;
}

//----------------------------------------------------------------------------
// 함수설명 : 멀티 프레임에서 Active 프레임을 지정한다.
//----------------------------------------------------------------------------
bool CImage::SetActiveFrame(int nFramePos)
{
	if( m_pImage == NULL ) return 0;

	GUID   pageGuid = FrameDimensionTime;

	Status status = m_pImage->SelectActiveFrame(&pageGuid, nFramePos);

	if( status != Ok ) return false;

	return true;
}

//----------------------------------------------------------------------------
// 함수설명 : 이미지를 지정된 크기로 변경한다.
//----------------------------------------------------------------------------
// 부가설명 : InterpolationModeHighQualityBicubic 을 기본으로 한다.
//----------------------------------------------------------------------------
bool CImage::SetSize(int nWidth, int nHeight)
{
	if( m_pImage == NULL) return false;

	//-----------------------------------------------------------------------
	// 새로운 크기가 변경된 영상을 얻는다.
	//-----------------------------------------------------------------------
	CImage * pSImage = GetSizeImage( nWidth, nHeight );

	if( pSImage == NULL) return false;
	
	//-----------------------------------------------------------------------
	// 프로세싱 이미지 객체를 확대/축소 된 객체로 변경한다.
	//-----------------------------------------------------------------------
	Bitmap * pTempImage = pSImage->m_pImage;
	pSImage->m_pImage = m_pImage;
	m_pImage = pTempImage;

	//-----------------------------------------------------------------------
	// 사용한 리소스들을 해제한다.
	//-----------------------------------------------------------------------
	delete pSImage;

	return true;
}


//----------------------------------------------------------------------------
// 함수설명 : 이미지를 지정된 비율로 늘이거나 줄인다.
//----------------------------------------------------------------------------
// 부가설명 : InterpolationModeHighQualityBicubic 을 기본으로 한다.
//----------------------------------------------------------------------------
bool CImage::SetScale(double dX, double dY)
{
	if( m_pImage == NULL) return false;

	//-----------------------------------------------------------------------
	// 스케일링된 이미지 객체를 얻어온다.
	//-----------------------------------------------------------------------
	CImage * pSImage = GetScaleImage(dX, dY);

	if( pSImage == NULL ) return false;

	//-----------------------------------------------------------------------
	// 프로세싱 이미지 객체를 확대/축소 된 객체로 변경한다.
	//-----------------------------------------------------------------------
	Bitmap * pTempImage = pSImage->m_pImage;
	pSImage->m_pImage = m_pImage;
	m_pImage = pTempImage;

	//-----------------------------------------------------------------------
	// 사용한 리소스들을 해제한다.
	//-----------------------------------------------------------------------
	delete pSImage;

	return true;
}

//----------------------------------------------------------------------------
// 함수설명 : 이미지를 지정된 각도만큼 회전한다.
//----------------------------------------------------------------------------
// 부가설명 : InterpolationModeHighQualityBicubic 을 기본으로 한다.
//----------------------------------------------------------------------------
bool CImage::SetRotate(double dRotate)
{
	if( m_pImage == NULL) return false;

	//-----------------------------------------------------------------------
	// 회전된 이미지 객체를 얻어온다.
	//-----------------------------------------------------------------------
	CImage * pRImage = GetRotateImage(dRotate);

	if( pRImage == NULL ) return false;

	//-----------------------------------------------------------------------
	// 프로세싱 이미지 객체를 회전된 객체로 변경한다.
	//-----------------------------------------------------------------------
	Bitmap * pTempImage = pRImage->m_pImage;
	pRImage->m_pImage = m_pImage;
	m_pImage = pTempImage;

	//-----------------------------------------------------------------------
	// 사용한 리소스들을 해제한다.
	//-----------------------------------------------------------------------
	delete pRImage;

	return true;
}

//----------------------------------------------------------------------------
// 함수설명 : 이미지를 Rotate, Flip 시킨다.
//----------------------------------------------------------------------------	
bool CImage::SetRotateFlip(RotateFlipType enumRotate)
{
	Status status = m_pImage->RotateFlip( enumRotate );

	if( status == Ok ) return true;

	return false;
}

//----------------------------------------------------------------------------
// 함수설명 : 지정된 크기로 변경된 이미지를 반환한다.
//----------------------------------------------------------------------------
// 부가설명 : InterpolationModeHighQualityBicubic 을 기본으로 한다.
//----------------------------------------------------------------------------
CImage* CImage::GetSizeImage(int nWidth, int nHeight)
{
	if( m_pImage == NULL) return NULL;

	//-----------------------------------------------------------------------
	// 새로운 영상을 생성한다.
	//-----------------------------------------------------------------------
	CImage * pSImage = new CImage( nWidth , nHeight, GetPixelFormat() );

	//-----------------------------------------------------------------------
	// 생성된 이미지객체에 비율에 맞게 확대/축소 출력한다.
	//-----------------------------------------------------------------------
	Graphics * pGraphics = pSImage->GetGraphics();

	//-----------------------------------------------------------------------
	// 출력될 Interpolation 모드를 지정한다.
	//-----------------------------------------------------------------------
	InterpolationMode Mode = SetInterpolationMode( InterpolationModeHighQualityBicubic );

	//-----------------------------------------------------------------------
	// 원영상을 확대된 크기로 새롭게 생성된 영상에 출력한다.
	//-----------------------------------------------------------------------
	Draw( pGraphics, 0, 0, nWidth, nHeight );

	SetInterpolationMode( Mode );

	//-----------------------------------------------------------------------
	// 사용한 리소스들을 해제한다.
	//-----------------------------------------------------------------------
	delete pGraphics;
	
	return pSImage;
}


//----------------------------------------------------------------------------
// 함수설명 : 지정된 비율로 늘이거나 줄여진 이미지를 반환한다.
//----------------------------------------------------------------------------
// 부가설명 : InterpolationModeHighQualityBicubic 을 기본으로 한다.
//----------------------------------------------------------------------------
CImage* CImage::GetScaleImage(double dX, double dY)
{
	if( m_pImage == NULL) return NULL;

	//-----------------------------------------------------------------------
	// 새로운 영상의 크기를 계산한다.
	//-----------------------------------------------------------------------
	int nSWidth = int( GetWidth()* dX + 0.3 );
	int nSHeight = int( GetHeight()* dY + 0.3 );

	//-----------------------------------------------------------------------
	// 새로운 영상을 생성한다.
	//-----------------------------------------------------------------------
	CImage * pSImage = new CImage( nSWidth , nSHeight, GetPixelFormat() );

	//-----------------------------------------------------------------------
	// 생성된 이미지객체에 비율에 맞게 확대/축소 출력한다.
	//-----------------------------------------------------------------------
	Graphics * pGraphics = pSImage->GetGraphics();

	//-----------------------------------------------------------------------
	// 출력될 Interpolation 모드를 지정한다.
	//-----------------------------------------------------------------------
	InterpolationMode Mode = SetInterpolationMode( InterpolationModeHighQualityBicubic );

	//-----------------------------------------------------------------------
	// 원영상을 확대된 크기로 새롭게 생성된 영상에 출력한다.
	//-----------------------------------------------------------------------
	Draw( pGraphics, 0, 0, nSWidth, nSHeight );

	SetInterpolationMode( Mode );

	//-----------------------------------------------------------------------
	// 사용한 리소스들을 해제한다.
	//-----------------------------------------------------------------------
	delete pGraphics;
		
	return pSImage;
}

//----------------------------------------------------------------------------
// 함수설명 : 지정된 각도만큼 회전된 이미지를 반환한다.
//----------------------------------------------------------------------------
// 부가설명 : InterpolationModeHighQualityBicubic 을 기본으로 한다.
//----------------------------------------------------------------------------
CImage* CImage::GetRotateImage(double dRotate, Color clrBackground)
{
	if( m_pImage == NULL) return NULL;

	//------------------------------------------------------------------------
	// 영상의 중점을 구한다.
	//------------------------------------------------------------------------
	double dGap = 0.3;

	int nXC = int( GetWidth()/2.0 + dGap );
	int nYC = int( GetHeight()/2.0 + dGap );

	//------------------------------------------------------------------------
	// 결과영상을 저장할 이미지를 생성하고 배경을 칠한다.
	//------------------------------------------------------------------------
	CImage * pRImage = new CImage( GetWidth(), GetHeight(), GetPixelFormat() );
	Graphics * pGraphics = pRImage->GetGraphics();
	
	SolidBrush brSolid( clrBackground );
	pGraphics->FillRectangle( &brSolid , Rect(0,0,GetWidth(),GetHeight()) );

	//------------------------------------------------------------------------
	// 그래픽스 객체를 얻어와 변환을 이용하여 회전된 영상을 출력한다.
	//------------------------------------------------------------------------
	pGraphics->TranslateTransform(nXC, nYC);
	pGraphics->RotateTransform(dRotate);

	Draw( pGraphics, -nXC, -nYC);

	delete pGraphics;

	return pRImage;
}

//----------------------------------------------------------------------------
// 함수설명 : Rotate, Flip 시킨 이미지를 반환한다.
//----------------------------------------------------------------------------	
CImage* CImage::GetRotateFlipImage(RotateFlipType enumRotate)
{
	if( m_pImage == NULL) return NULL;

	//------------------------------------------------------------------------
	// 원영상을 복제하여 RotateFlip 함수를 수행한다.
	//------------------------------------------------------------------------
	CImage * pImage = Clone();

	if( !pImage->SetRotateFlip( enumRotate ) )
	{
		delete pImage;
		return NULL;
	}

	return pImage;
}

//----------------------------------------------------------------------------
// 함수설명 : 이미지가 로드되어 있는지를 체크한다.
//----------------------------------------------------------------------------	
bool CImage::IsValid()
{
	if( m_pImage == NULL ) return false;

	return true;
}

